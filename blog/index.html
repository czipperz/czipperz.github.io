<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../style.css" />
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=sunburst"></script>
    <title> Czipperz's Blog - C++ galore </title>
  </head>
  <body>
    <div id="page">
      <div id="top">
        <h1 id="title"> Czipperz's Blog - C++ galore </h1>
      </div>
      <div id="content">
        <div class="article">
          <h2><a> Java to C++ - <code>const</code> and references. </a></h2>
          <h4 class="date">9/23/2015</h4>
          <p>
            As we saw in the last post, <i>Java to C++ -
            Destructors</i>, giving a <code>string</code> to
            the <code>getline</code> function will modify it to be the
            current line buffered by the stream.  This is really cool,
            but it is dangerous because the side effects, or places
            where variables change, can be obscured.
          </p>
          <br />
          <p>
            C++ helps to ease this pain by allowing you to declare a
            variable as <code>const</code>.  This allows you to only
            use functions on it that don't modify the state of the
            object, or read public variables from the object.  Passing
            a variable by constant reference is a really cool feature
            that allows a function to look at the contents but not
            modify them.
          </p>
          <br />
          <p>
            <code>const</code> is very similar to
            the <code>final</code> keyword, but <i>much more
            powerful</i>.  Every type in Java is a pointer, meaning
            that it is really just a value that tells you where to
            look for the actual value.  The final keyword just tells
            the compiler that you can't change the address that the
            pointer points to, but the const keyword does that too!
          </p>
          <br />
          <p>
            An ampersand after a type but before the name of a
            variable tells the compiler that it is a reference.  Let's
            look at an example.
          </p>
          <br />
          <pre class="prettyprint">
            #include &lt;assert.h&gt;
            #include &lt;string&gt;

            int main() {
                std::string str = "Hello World!";
                const std::string  immutable_copy      = str;
                const std::string& immutable_reference = str;

                str = "Different string";

                // compile errors, can't change state of const object:
                // immutable_reference = "";
                // immutable_copy = "";

                assert(immutable_copy == "Hello World!");
                assert(immutable_reference == "Different string");

            // str and immutable_copy are deleted at this closing brace.
            // immutable_reference doesn't need to be deleted as it isn't a value type.
            }
          </pre>
          <p>
            As you can see, the reference maintains shares the same
            memory as the value, <code>str</code>.  References are
            just like final objects in Java.  The key difference
            between references and pointers are that references cannot
            be <code>null</code> as they have to point to a memory
            location when they are declared.  This gives them
            incredible power as parameters because null checks are
            redundant.
          </p>
          <br />
          <p>
            You can see that the <code>.equals()</code> method isn't
            used to compare objects because you can just overload
            the <code>==</code> operator.  Don't worry, you can still
            compare memory addresses, but we'll get to that later.
            Operator overloading is a very powerful feature of C++
            that isn't in Java.  It allows you to treat classes as
            builtin types, which I'll post later about.
          </p>
          <br />
          <p>
            The main reason references are so popular is that they can
            make a huge improvement over value types for arguements to
            a method.  A value type is one that is not a pointer or
            reference.  They aren't very popular as they have to
            be <i>cloned when used as an argument</i>.  Let's look at
            an example of const references used as function inputs.
            These are a popular subgenre because they ensure that
            there won't be a change to the object passed in while
            maintaining high performance.
          </p>
          <pre class="prettyprint">
            #include &lt;string&gt;

            std::string concat(std::string a, std::string b) {
                return a + b;
            }
          </pre>
          <p>
            The problem with this code is that the strings are passed
            by value but then not modified, making that operation
            unnecessary and a waste of resources.  To get a nice
            performance boost, all we have to change is the
            declaration of the function!
          </p>
          <pre class="prettyprint">
            std::string concat(const std::string& a, const std::string& b) {
                return a + b;
            }
          </pre>
          <p>
            You might think that returning a reference to the string
            created by the <code>+</code> operator would be a good
            idea, but that would enact <i>undefined behavior</i>.
            This is because the result of the <code>+</code> operator
            is deleted at the closing brace, but with a value type the
            compiler will optimize the unnecessary copy and immediate
            deletion and just return the value.  A general rule of
            thumb is to never return a reference if it points to a
            variable declared during the scope of the function.
          </p>
        </div>
        <div class="article">
          <h2><a> Java to C++ - Destructors. </a></h2>
          <h4 class="date">9/22/2015</h4>
          <p>
            C++ is not a managed language.  This basically means that
            there is no garbage collector.  The good thing about this is
            that there is no startup time or garbage collector overhead.
            The design goal of C++ was to be:
          </p>
          <ul>
            <li>Extremely general/flexible</li>
            <li>Zero-overhead abstractions</li>
            <li>Well-specified interfaces</li>
          </ul>
          <span style="font-size:12px">Source: Bjarne Stroustrup,
            inventor of C++ <i>"Make Simple Tasks Simple!"</i> CppCon 2014</span>
          <br /> <br />

          <p>
            This means that they make speedups that may not seem right
            until you understand the reasoning behind it.  But this post
            is about destructors, arguably the best feature of C++ that
            doesn't exist in Java.  Destructors force the destruction of
            resources when a block of code ends.  Let's look at an
            example:
          </p>
          <pre class="prettyprint">
            #include &lt;fstream&gt;
            #include &lt;iostream&gt;
            #include &lt;string&gt;

            int main() {
                using namespace std;

                ifstream file_stream("file");
                string first_line;
                getline(file_stream, first_line);

                cout << "First line of file is: " << first_line << endl;
            }
          </pre>
          <p>
            The first two lines tell the compiler to basically import
            the file stream and input output stream headers (fstream and
            iostream respectively).  The &lt;&gt; around the name tells
            it that it is a system header and that you didn't make it.
          </p>
          <br />
          <p>
            The line <code>using namespace std;</code> tells the
            compiler to look up any members it doesn't see itself in the
            namespace <code>std</code>.  For example, this shortens the
            usage of <code>std::cout</code> to <code>cout</code>.
          </p>
          <br />
          <p>
            The <code>ifstream</code> allow you to read input from a
            file, assuming that it exists.  We will for the sake of the
            example.  In Java you would have to wrap this operation in a
            try catch block, then close the resource at the end.  If an
            exception occurs that you don't catch, the file will never
            be closed!  In C++ the destructor for an object will always
            be called when the resource falls out of scope: in this case
            at the end of the main function.  This makes sure that
            resources are properly disposed <i>no matter what</i>,
            removing the resource cleanup strain from the user, the
            point of a garbage collector in the first place!
          </p>
          <br />
          <p>
            The line <code>string first_line;</code> allocates a
            string that will be deleted when the main function ends.
            Writing <code>String firstLine;</code> in Java will
            allocate a <i>pointer</i> to a String but won't actually
            allocate it.  You can do the exact same thing, but it is
            bad form.  It is very similar to a <code>String</code> in
            Java except that it is modifiable.  You may think that
            immutable Strings in Java are a great feature and they
            are, but C++ allows you a variable as immutable by adding
            the keyword <code>const</code> rather than designing two
            different classes to do the same thing.  This has a great
            speed improvement as you don't have central cache of
            immutable strings and don't need multiple allocations for
            one string object.
          </p>
          <br />
          <p>
            The last line of real code is a function call
            of <code>getline</code>.  This reads a line out of a stream
            and puts it into the second variable given, a string
            reference.  A reference simply means that that other method
            can change the contents of it, just like a normal Object in
            Java.
          </p>
          <br />
          <p>
            The final line just prints out the first line of the file
            that you acquired in the <code>getline()</code> statement.
          </p>
          <br />
          <p>
            All the destructors are actually called at the very last
            line, the <code>}</code>.  First the <code>string
              first_line</code> will be deleted, then
            the <code>ifstream</code>.  This ensures that the
            resources acquired are deleted no matter what happens
            after they are aquired: a process called RAII - Resource
            Acquisition Is Initialization.
        </div>
        <div class="article">
          <h2><a> Java to C++ - Hello World. </a></h2>
          <h4 class="date">9/21/2015</h4>
          <p>
            What is the difference between C++ and Java?  People
            experienced with both languages will give you a list of
            their favorite features not available in the other.  But it
            doesn't really matter.  What I care about are the features
            that make it so that my code makes sense.  Maybe not as
            readable <i>at first</i>, but makes sense once you
            understand it.  Lets look at some simple Java code then
            translate it to C++:
          </p>
          <pre class="prettyprint">
            // Java
            public class Begin {
                public static void main(String[] args) {
                    System.out.println("Hello World!");
                }
            }
          </pre>
          <pre class="prettyprint">
            // C++
            #include &lt;iostream&gt;
            int main() {
                std::cout << "Hello World!" << std::endl;
            }
          </pre>
          <p>
            This code is honestly fairly similar.  The main difference
            is that printing is done by using the
            overloaded <code>&lt;&lt;</code> operator of the global
            variable <code>std::cout</code>.  Overloading this operator
            makes the code much more understandable: just push the bits
            from the <code>"Hello World!"</code> string into the output.
            You will also notice that you don't need to have a class
            wrapped around the main statement for it to work!  C++ has
            objects, they look and work very similar to those in Java,
            but it discourages you from using them when it doesn't make
            sense to do so.
          </p>
          <br />
          <p>
            You'll also notice the weird <code>#include</code> line.
            This informs the compiler that you want to use the functions
            provided by the iostream header provided in the standard
            library.  It literally means that the compiler will just
            substitute in the entire file at that point then actually
            compile the program.
          </p>
          <br />
          <p>
            C++ really isn't very complicated compared to Java, it just
            does things differently and faster.
          </p>
        </div>
      </div>
    </div>
  </body>
</html>
